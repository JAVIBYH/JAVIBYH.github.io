[{"title":"网络编程","url":"/2019/07/22/corejava_net/","content":"\n## 基于TCP的Socket编程步骤：\n+ 套接字socket：代表通信节点\n\t- 实质：一种独立于协议的网络编程接口。\n\t* 作用：完成两个应用程序之间的数据传输。\n\t+ 类型：流式套接字、数据报套接字、原始套接字。\n1. **服务器程序编写：**\n\t* ①调用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上；\n\t* ②调用accept()，监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字；\n\t* ③调用Socket类的getInputStream和getOutputStream()获取输入流和输出流，开始网络数据的接收和发送；\n\t* ④最后关闭通信套接字。\n2. **客户端程序编写：**\n\t* ①调用Socket()创建一个流套接字，并连接到服务器端； \n\t* ②调用Socket类的getOutputStream()和getInputStream获取输出流和输入流，开始网络数据的发送和接收； \n\t* ③最后关闭通信套接字。\n\n---\n\n**服务端和客户端简单交互**\n\n服务端：\n\n```java\n//基于TCP协议的服务端\npublic class TcpServer {\n\tpublic static void main(String[] args) {\n\t\tServerSocket ss = null;  //声明\n\t\tBufferedReader br = null;\n\t\tPrintWriter pw = null;\n\t\tSocket socket = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建ServerSocket对象\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经在9999端口启动！\");\n\t\t\twhile(true){\n\t\t\t\t//2.监听连接请求，等待客户端请求连接\n\t\t\t\tsocket = ss.accept();  //阻塞作用\n\t\t\t\t//3.基于Socket对象读写数据\n\t\t\t\t//读客户端发来的数据\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t\t//给客户端发出数据\n\t\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\t\tpw.println(new Date().toString());\n\t\t\t\tpw.flush();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\t//关闭资源(先开后关)\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(socket!=null)\tsocket.close();\n\t\t\t\tif(ss!=null)\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n```java\n//基于TCP协议的服务器端，使用多线程\npublic class TcpServer2 {\n\tprivate ServerSocket ss;\n\t\n\tpublic TcpServer2() {\n\t\ttry {\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经启动....\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\t//每来一个客户端就启动一个线程来单独处理该客户端和服务端的通信\n\t\t\t\tnew ServerThread(socket).start();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew TcpServer2();\n\t}\n}\nclass ServerThread extends Thread{\n\tprivate Socket socket;\n\t\n\tpublic ServerThread(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t@Override\n\tpublic void run(){\n\t\t//3.基于Socket对象读写数据\n\t\t//读客户端发来的数据\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t//给客户端发出数据\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(new Date().toString());\n\t\t\tpw.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\n//基于TCP的客户端\npublic class TcpClient {\n\tpublic static void main(String[] args) {\n\t\tSocket socket = null;\n\t\tPrintWriter pw = null;\n\t\tBufferedReader br = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建Socket对象，并绑定IP地址和端口号\n\t\t\tsocket = new Socket(\"127.0.0.1\",9999);\n\t\t\t//2.基于Socket的读写数据\n\t\t\t//客户端给服务端写数据\n\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(\"请给我你的时间！\");\n\t\t\tpw.flush();\n\t\t\t//接受服务器发来的数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString time = br.readLine();\n\t\t\tSystem.out.println(\"时间为：\"+time);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(socket!=null) \tsocket.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n---\n\n**聊天室模拟**\n\n服务端：\n\n```java\n//聊天室的服务端\npublic class ChatServer {\n\tprivate ServerSocket ss;\n\tprivate Set<Socket> clients;\n\t\n\tpublic ChatServer(){\n\t\ttry {\n\t\t\tss = new ServerSocket(8888);\n\t\t\tclients = new HashSet<Socket>();\n\t\t\tSystem.out.println(\"聊天室的服务器端已经启动...\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\tclients.add(socket);\n\t\t\t\t//启动一个线程单独处理该客户端\n\t\t\t\tnew ChatThread(socket,clients).start();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew ChatServer();\n\t}\n}\n\n//接收客户端的数据并转发给所有的客户端\nclass ChatThread extends Thread{\n\tprivate Socket currentSocket;  //当前客户端\n\tprivate Set<Socket> clients;\n\tpublic ChatThread(Socket currentSocket,Set<Socket> clients) {\n\t\tthis.currentSocket = currentSocket;\n\t\tthis.clients = clients;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\t//读数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(currentSocket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//转发给所有的客户端\n\t\t\t\tfor(Socket client:clients){\n\t\t\t\t\tPrintWriter pw = new PrintWriter(client.getOutputStream());\n\t\t\t\t\tpw.println(str);\n\t\t\t\t\tpw.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class ChatClient extends JFrame {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate JTextArea sendArea;//要发送信息的内容区域\n\tprivate JTextArea contentArea;//聊天记录的内容区域\n\tprivate Container contentPane;\n\tprivate String name;//当前用户名\n\tprivate Socket socket;\n\t\n\tpublic static void main(String[] args) throws UnknownHostException, IOException {\n\t\tSocket socket = new Socket(\"127.0.0.1\",8888);\n\t\tnew ChatClient(\"张三\",socket).go();\n\t}\n\tpublic ChatClient(String name,Socket socket){\n\t\tthis.name = name;\n\t\tthis.socket = socket;\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tinitGUI();\n\t\t//启动一个子线程，专门接收服务器端传来的数据\n\t\tnew ClientThread(socket,contentArea).start();\n\t}\n\tpublic void initGUI(){\n\t\tthis.setSize(300,400);\n\t\tthis.setTitle(\"我的聊天室\");\n\t\tcontentPane = getContentPane();\n\t\tint x = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();\n\t\tint y = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();\n\t\tthis.setLocation((x-this.getWidth())/2, (y-this.getHeight())/2);\n\t\tthis.setResizable(false);\n\t\t\n\t\tcontentArea = new JTextArea();\n\t\tcontentArea.setEditable(false);\n\t\tJScrollPane logPanel = new JScrollPane(contentArea,\n\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tsendArea = new  JTextArea();\n\t\tsendArea.addKeyListener(new KeyAdapter() {\n\t\t\t public void keyPressed(KeyEvent e) {\n\t\t\t\t if(e.getKeyCode()==KeyEvent.VK_ENTER){\n\t\t\t\t\t send();\n\t\t\t\t }\n\t\t\t }\n\t\t});\n\t\tJScrollPane sendPanel = new JScrollPane(sendArea,\n\t\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t//创建一个分割窗口\n\t\tJSplitPane splitPane = new JSplitPane(\n\t\t\t\tJSplitPane.VERTICAL_SPLIT,logPanel,sendPanel);\n\t\tsplitPane.setDividerLocation(250);\n\t\tcontentPane.add(splitPane,BorderLayout.CENTER);\n\t\t\n\t\t//下面的\n\t\tJPanel jp = new JPanel();\n\t\tjp.setLayout(new FlowLayout(FlowLayout.RIGHT));\n\t\tcontentPane.add(jp,BorderLayout.SOUTH);\n\t\t\n\t\tJLabel nameLbl = new JLabel(\"用户名：\"+this.name+\" \");\n\t\tjp.add(nameLbl);\n\t\t\n\t\tJButton resetBtn = new JButton(\"close\");\n\t\tresetBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t});\n\t\tjp.add(resetBtn);\n\t\t\n\t\tJButton sendBtn = new JButton(\"send\");\n\t\tjp.add(sendBtn);\n\t\tsendBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tsend();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void go(){\n\t\tthis.setVisible(true);\n\t}\n\tpublic void send (){\n\t\t//获取要发送的信息\n\t\tString msg = sendArea.getText();\n\t\tSimpleDateFormat formater = new SimpleDateFormat(\"HH:mm:ss\");\n\t\tString date = formater.format(new Date());\n\t\tString sendStr = name+\" \"+date+\"说： \"+msg;\n\t\t\n\t\ttry {\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\t//发送数据给服务器\n\t\t\tpw.println(sendStr);\n\t\t\tpw.flush();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t//contentArea.append(sendStr+\"\\n\");\n\t\tsendArea.setText(\"\");\n\t}\n}\n\n//接收服务器端的数据，并显示在界面上\nclass ClientThread extends Thread{\n\tprivate Socket socket;\n\tprivate JTextArea contentArea;\n\t\n\tpublic ClientThread(Socket socket,JTextArea contentArea){\n\t\tthis.socket = socket;\n\t\tthis.contentArea = contentArea;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//显示在界面上\n\t\t\t\tcontentArea.append(str+\"\\n\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n---\n\n## 基于UDP的Socket编程步骤：\n1. **服务器端基于UDP编程：**\n\t- a) 调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上；\n\t- b) 调用DatagramPacket(byte[] buf, int length)，建立一个字节数组以接收客户端的UDP包 ；\n\t- c) 调用DatagramSocket类的receive()，接收客户端的UDP包并放在上一步创建的数据包中；通过调用DatagramPacket的getData获取数据。\n\t- d) 创建数据包，用来存放发送给客户端响应数据。\n```\n\tint port = dp.getPort();\n\tInetAddress address=dp.getAddress();\n\tString msg=new Date().toString();\n\tbuf=msg.getBytes();\n\tDatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port);\n```\n\t- e) 向客户端发送数据包DatagramSocket.send(DatagramPacket)\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n2. **客户端程序编写：**\n\t- a) 调用DatagramSocket()创建一个数据报套接字。 \n\t- b) 调用DatagramPacket(byte[] buf, int length, InetAddress address, int port)，建立要发送的UDP包；\n\t\t包含发给服务器的数据，服务器地址，服务器的端口。\n\t- c) 调用DatagramSocket类的send(dp)，发送UDP包；\n\t- d) 创建数据包，用来存放服务器端返回响应数据。\n```\n\t\t   DatagramPacket dp1=new DatagramPacket(buf,buf.length);\n```\n\t- e) 接收服务器端响应数据ds.receive(dp1);\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n\n---\n\n**UDP服务端客户端简单交互**\n\n服务端：\n\n```java\n//基于UDP协议的服务端\npublic class UDPServer {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//1.创建DatagramSocket对象，并绑定端口号\n\t\tDatagramSocket ds = new DatagramSocket(8899);\n\t\tSystem.out.println(\"服务器端已经在8899端口启动......\");\n\t\t//2.接收数据包\n\t\tbyte[] buf = new byte[2048];  //存放数据\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp);//有阻塞功能\n\t\t//3.输出数据包中内容\n\t\tString str = new String(dp.getData());\n\t\tSystem.out.println(\"接收到客户端数据为：\"+str);\n\t\t\n\t\t//4.发送数据包(内容，客户端IP和port\n\t\tString message = new Date().toString();\n\t\tbuf = message.getBytes();  //需要发送的数据\n\t\tint port = dp.getPort();  //获取客户端的端口号\n\t\tInetAddress address = dp.getAddress(); //客户端IP地址\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length, address, port);\n\t\tds.send(dp1);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class UDPClient {\n\tpublic static void main(String[] args) throws Exception{\n\t\t//1.创建DatagramSocket对象，绑定IP地址和端口号\n\t\tDatagramSocket ds = new DatagramSocket();\n\t\t//2.发送数据包\n\t\tbyte[] buf = new byte[2048];\n\t\tbuf = \"give me your time\".getBytes();\n\t\tInetAddress address = InetAddress.getByName(\"127.0.0.1\");  //根据主机名获取InetAddress对象\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length,address,8899);\n\t\tds.send(dp);\n\t\t//3.接收数据包\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp1);\n\t\t//输出数据包数据\n\t\tString message = new String(dp1.getData());\n\t\tSystem.out.println(\"接收服务器端数据:\"+message);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n\n","tags":["java基础"],"categories":["corejava"]},{"title":"IO流","url":"/2019/07/15/io/","content":"# 第七章 IO流\n## 一、流的概念\n+ Java中流是使用统一的方式操作输入和输出的数据。\n+ java.io包它对各种常见的输入流和输出流进行了抽象。\n## 二、流的分类\n1. 流操作的方向（参照物：当前程序）\n   + **输入流**：将数据读取到程序中。\n   + **输出流**：将程序中的数据写出到文件中。\n2. 类操作的最小数据单元\n   + **字节类**：如果数据流中最小的数据单元是字节，那么称这种流为字节流。字节流处理单元为 1 个字节，可以操作字节和字节数组。\n   + **字符类**：如果数据流中最小的数据单元是字符，那么称这种流为字符流。字符流处理的单元为 2 个字节的 Unicode 字符，可以操作字符、字符数组或字符串。Java内用Unicode 编码存储字符,字符流处理类负责将外部的其他编码的字符流和java内Unicode 字符流之间的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。\n3. 流的角色\n   + **字节流**：处理实际数据源，上述四种都是属于字节流。如*FileInputStream*。\n   + **处理流/包装流**:处理包装的流。如*BufferedInputStream*。\n## 三、几种重要的流\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;\n1. 所有字节输入流和字节输出流的父类：\n   + java.io.InputStream\n   + java.io.OutputStream\n2. 文件字节流:\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;","tags":["java基础"],"categories":["corejava"]},{"title":"shangchuantupian","url":"/2019/07/14/shangchuantupian/"},{"url":"/2019/06/26/thread/","content":"# 线程"},{"url":"/2019/06/21/MyFirstBlog/","content":"这是我的第一篇博客。"},{"title":"Hello World","url":"/2019/06/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]