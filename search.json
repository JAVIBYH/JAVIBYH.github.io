[{"title":"网络编程","url":"/2019/07/22/corejava_net/","content":"\n## 基于TCP的Socket编程步骤：\n+ 套接字socket：代表通信节点\n\t- 实质：一种独立于协议的网络编程接口。\n\t* 作用：完成两个应用程序之间的数据传输。\n\t+ 类型：流式套接字、数据报套接字、原始套接字。\n1. **服务器程序编写：**\n\t* ①调用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上；\n\t* ②调用accept()，监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字；\n\t* ③调用Socket类的getInputStream和getOutputStream()获取输入流和输出流，开始网络数据的接收和发送；\n\t* ④最后关闭通信套接字。\n2. **客户端程序编写：**\n\t* ①调用Socket()创建一个流套接字，并连接到服务器端； \n\t* ②调用Socket类的getOutputStream()和getInputStream获取输出流和输入流，开始网络数据的发送和接收； \n\t* ③最后关闭通信套接字。\n\n---\n\n```java\n//基于TCP协议的服务端\npublic class TcpServer {\n\tpublic static void main(String[] args) {\n\t\tServerSocket ss = null;  //声明\n\t\tBufferedReader br = null;\n\t\tPrintWriter pw = null;\n\t\tSocket socket = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建ServerSocket对象\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经在9999端口启动！\");\n\t\t\twhile(true){\n\t\t\t\t//2.监听连接请求，等待客户端请求连接\n\t\t\t\tsocket = ss.accept();  //阻塞作用\n\t\t\t\t//3.基于Socket对象读写数据\n\t\t\t\t//读客户端发来的数据\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t\t//给客户端发出数据\n\t\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\t\tpw.println(new Date().toString());\n\t\t\t\tpw.flush();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\t//关闭资源(先开后关)\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(socket!=null)\tsocket.close();\n\t\t\t\tif(ss!=null)\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n---\n## 基于UDP的Socket编程步骤：\n1. **服务器端基于UDP编程：**\n\t- a) 调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上；\n\t- b) 调用DatagramPacket(byte[] buf, int length)，建立一个字节数组以接收客户端的UDP包 ；\n\t- c) 调用DatagramSocket类的receive()，接收客户端的UDP包并放在上一步创建的数据包中；通过调用DatagramPacket的getData获取数据。\n\t- d) 创建数据包，用来存放发送给客户端响应数据。\n```\n\tint port = dp.getPort();\n\tInetAddress address=dp.getAddress();\n\tString msg=new Date().toString();\n\tbuf=msg.getBytes();\n\tDatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port);\n```\n\t- e) 向客户端发送数据包DatagramSocket.send(DatagramPacket)\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n2. **客户端程序编写：**\n\t- a) 调用DatagramSocket()创建一个数据报套接字。 \n\t- b) 调用DatagramPacket(byte[] buf, int length, InetAddress address, int port)，建立要发送的UDP包；\n\t\t包含发给服务器的数据，服务器地址，服务器的端口。\n\t- c) 调用DatagramSocket类的send(dp)，发送UDP包；\n\t- d) 创建数据包，用来存放服务器端返回响应数据。\n```\n\t\t   DatagramPacket dp1=new DatagramPacket(buf,buf.length);\n```\n\t- e) 接收服务器端响应数据ds.receive(dp1);\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n\n---\n\n","tags":["java基础"],"categories":["corejava"]},{"title":"IO流","url":"/2019/07/15/io/","content":"# 第七章 IO流\n## 一、流的概念\n+ Java中流是使用统一的方式操作输入和输出的数据。\n+ java.io包它对各种常见的输入流和输出流进行了抽象。\n## 二、流的分类\n1. 流操作的方向（参照物：当前程序）\n   + **输入流**：将数据读取到程序中。\n   + **输出流**：将程序中的数据写出到文件中。\n2. 类操作的最小数据单元\n   + **字节类**：如果数据流中最小的数据单元是字节，那么称这种流为字节流。字节流处理单元为 1 个字节，可以操作字节和字节数组。\n   + **字符类**：如果数据流中最小的数据单元是字符，那么称这种流为字符流。字符流处理的单元为 2 个字节的 Unicode 字符，可以操作字符、字符数组或字符串。Java内用Unicode 编码存储字符,字符流处理类负责将外部的其他编码的字符流和java内Unicode 字符流之间的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。\n3. 流的角色\n   + **字节流**：处理实际数据源，上述四种都是属于字节流。如*FileInputStream*。\n   + **处理流/包装流**:处理包装的流。如*BufferedInputStream*。\n## 三、几种重要的流\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;\n1. 所有字节输入流和字节输出流的父类：\n   + java.io.InputStream\n   + java.io.OutputStream\n2. 文件字节流:\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;","tags":["java基础"],"categories":["corejava"]},{"title":"shangchuantupian","url":"/2019/07/14/shangchuantupian/"},{"url":"/2019/06/26/thread/","content":"# 线程"},{"url":"/2019/06/21/MyFirstBlog/","content":"这是我的第一篇博客。"},{"title":"Hello World","url":"/2019/06/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]