[{"title":"使用数组链表实现ArrayList和LinkedList","url":"/2019/08/25/corejava_ArrayListAndLinkedList/","content":"\n## 使用数组实现ArrayList,使用链表实现LinkList\n\n* 接口，提供规范\n\n```\n//提供对数据增删改查的规范\npublic interface List {\n\n\tpublic void add(Object obj);   //在数据结构最后位置添加对象\n\tpublic void add(int index,Object obj);//在指定位置添加对象\n    public Object remove(int index);//删除指定位置上的对象\n    public void set(int index,Object obj);  //修改指定位置上的数据\n\tpublic Object get(int index);//获取指定位置上的数据\n\tpublic int size(); //获取当前数据结构当前的长度\n\tpublic Iterator iterator();  //获取当前数据结构的迭代器\n\t\n}\n```\n\n* 提供遍历元素标准\n\n```\n//提供遍历集合中元素的标准\npublic interface Iterator {\n\t\n\tpublic boolean hasNext();  //判断是否有下一个元素\n\tpublic Object next();   //取出集合中一个元素\n\tpublic void remove();   //删除一个元素，迭代器遍历到的位置,迭代器删除后要往后退一个位置（这样就可以判断下一个元素）\n\n}\n```\n\n* 实现类 ArrayList\n\n```\n//实现类：使用数组实现ArrayList功能\npublic class ArrayList implements List{\n\n\tprivate Object[] array;\n\tprivate int length;\n\tprivate int size;\n\t\n\tpublic ArrayList() {\n\t\tthis(10);\n\t}\n\t\n\tpublic ArrayList(int length){\n\t\tarray = new Object[length];\n\t\tthis.length = length;\n\t}\n\t\n\t@Override\n\tpublic void add(Object obj) {\n\t\tadd(size,obj);\n\t}\n\n\t//扩容\n\tprivate void check(){\n\t\tif(size>=length){\n\t\t\tObject[] nArray = new Object[length*2];\n\t\t\tSystem.arraycopy(array, 0, nArray, 0, size);\n\t\t\tarray = nArray;\n\t\t\tlength *= 2;\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void add(int index, Object obj) {\n        check();\n        if(index>size||index<0){\n        \tSystem.out.println(\"添加位置不对!\");\n        \treturn;\n        }\n        for(int i=size;i>index;i--){\n        \tarray[i] = array[i-1];\n        }\n        //System.arraycopy(array, index, array, index+1, size-index);\n\t\tarray[index] = obj;\n\t\tsize++;\n\t}\n\n\t@Override\n\tpublic Object remove(int index) {\n\t\tif(index<0||index>=size)\n\t\t{\n\t\t\tSystem.out.println(\"删除错误!\");\n\t\t\treturn 0;\n\t\t}\n\t\tObject obj = array[index];\n\t\tfor(int i=index;i<size-1;i++){\n\t\t\tarray[i] = array[i+1];\n\t\t}\n\t\t//System.arraycopy(array, index+1, array, index, size-index-1);\n\t\tarray[--size] = null;\n\t\treturn obj;\n\t}\n\n\t@Override\n\tpublic void set(int index, Object obj) {\n\t\t if(index<0||index>=size) return;\n\t\t array[index] = obj;\n\t\t\n\t}\n\n\t@Override\n\tpublic Object get(int index) {\n\t\tif(index<0||index>=size) {\n\t\t\treturn 0;\n\t\t}\n\t\t\t\n\t\treturn array[index];\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\t//\n\t@Override\n\tpublic Iterator iterator() {\n\t\treturn new ArrayIterator();\n\t}\n\n\t//内部类\n\tclass ArrayIterator implements Iterator{\n\n\t\tprivate int position = -1;   //迭代器当前位置\n\t\t\n\t\t@Override\n\t\tpublic boolean hasNext() {  //是否有下一个元素\n\t\t\tif(position+1<size){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object next() {   //取到下一个元素\n\t\t\treturn get(++position);\n\t\t}\n\n\t\t@Override\n\t\tpublic void remove() {    //删除当前元素\n\t\t\tArrayList.this.remove(position--);\n\t\t}\n\t\t\n\t}\n\t\n}\n```\n\n* 测试类\n\n```\npublic class Test {\n\t\n\tpublic static void main(String[] args) {\n\t\t//List list = new ArrayList();\n\t\tList list = new LinkedList();\n\t\tlist.add(10);\n\t\tlist.add(true);\n\t\tlist.add(\"hello\");\n\t\tlist.add(1,\"world\");\n\t\tlist.add(2,100);\n\t\t\n\t\tObject result = list.remove(2);\n\t\tSystem.out.println(\"删除：\"+result);\n\t\t\n\t\tlist.set(2, \"briup\");\n\t\t\n\t\t//输出\n\t\t/*for(int i=0;i<list.size();i++){\n\t\t\tSystem.out.print(list.get(i)+\" \");\n\t\t}*/\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"===================\");\n\t\t //迭代器输出\n\t\tIterator iter = list.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tObject obj = iter.next();\n\t\t\tSystem.out.print(obj+\" \");\n\t\t} \n\t}\n}\n\n```\n\n* 实现LinkList,节点类型\n\n```\n//节点类型\npublic class Node {\n\t \n\tprivate Object data;// 节点的真正数据\n\tpublic Node next;// 下一个节点的地址\n\t\n\tpublic Node(Object data){\n\t\tthis.data = data;\n\t}\n\t\n\tpublic Node(Object data,Node next){\n\t\tthis.data = data;\n\t\tthis.next = next;\n\t}\n\t\n\tpublic void setData(Object data){\n\t\tthis.data = data;\n\t}\n\t\n\tpublic Object getData(){\n\t\treturn data;\n\t}\n}\n```\n\n* 实现类\n\n```\n//实现类：使用单向链表实现LinkedList功能\npublic class LinkedList implements List{\n\n\tprivate Node head;  //头节点   头结点一定要定义好，因为链表就是从第一个往后一直找，找到你想要的\n\tprivate int size;   //当前对象个数\n\t\n\tpublic LinkedList() {\n\t\t//创建头节点\n\t\thead = new Node(null);\n\t\thead.next = null;    \n\t}\n\t\n\t@Override\n\tpublic void add(Object obj) {\n\t\tadd(size,obj);\n\t}\n\n\t@Override\n\tpublic void add(int index, Object obj) {\n\t\tif(index<0||index>size){\n\t\t\tSystem.out.println(\"添加错误!\");\n\t\t\treturn;\n\t\t}\n\t\tNode curr = head;  //当前节点\n\t\t/*初始化是从头结点开始通过for循环将在指定插入位置前的curr.next一直赋给临时变量curr，\n\t\t  将来将curr.next地址赋值给新插入创建的node，将新new的node地址给原来指向的的curr.next,通过画图来说明插入*/\n\t\tfor(int i=0;i<index;i++){\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tNode node = new Node(obj);   //新结点\n\t\tnode.next = curr.next;\n\t\tcurr.next= node;\n\t\tsize++;\n\t\t\n\t}\n\n\t@Override\n\tpublic Object remove(int index) {\n\t\tif(index<0||index>=size){\n\t\t\treturn null;\n\t\t}\n\t\tNode curr = head;\n\t\tNode pre = null;   //当前节点的上一个节点\n\t\tfor(int i=0;i<=index;i++){\n\t\t\tpre = curr;\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tpre.next = curr.next;\n\t\tcurr.next = null;\n\t\tsize--;\n\t\treturn curr.getData();\n\t}\n\n\t@Override\n\tpublic void set(int index, Object obj) {\n\t\tif(index<0||index>size){\n\t\t\treturn;\n\t\t}\n\t\tNode curr = head;\n\t\tfor(int i=0;i<=index;i++){\n\t\t\tcurr = curr.next;\n\t\t}\n\t\tcurr.setData(obj);\n\t}\n\n\t@Override\n\tpublic Object get(int index) {\n\t\tif(index<0||index>=size){\n\t\t\treturn null;\n\t\t}\n\t\tNode curr = head;  //当前节点\n\t    for(int i=0;i<=index;i++){\n\t    \tcurr = curr.next;\n\t    }\n\t\treturn curr.getData();\n\t}\n\n\t@Override\n\tpublic int size() {\n\t\treturn size;\n\t}\n\n\t\n\t//匿名内部类\n\t@Override\n\tpublic Iterator iterator() {\n\t\treturn new Iterator(){\n\t\t\t\n\t\t\tprivate int position = -1;\n\t\t\t\n\t\t\tpublic boolean hasNext(){\n\t\t\t\tif(position+1<size){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Object next(){\n\t\t\t\treturn get(++position);\n\t\t\t}\n\t\t\t\n\t\t\tpublic void remove(){\n\t\t\t\tLinkedList.this.remove(position--);\n\t\t\t}\n\t\t\t\n\t\t};\n\t}\n\n}\n```\n\n","categories":["corejava"]},{"title":"Set和List排序问题","url":"/2019/08/25/corejava_ListAndSet/","content":"\n## Set和List排序问题\n\n* 使用TreeSet和Comparator,写TreeSetTest1.java\n要求：对TreeSet中的元素\"HashSet\"、\"ArrayList\"、\"TreeMap\"、\"HashMap\"、\"TreeSet\"、\"LinkedList\"进行升序和倒序排列列\n\n\n* a)使用匿名内部类实现    TreeSetTest11.java\n\n\n```\npublic class TreeSetTest11 {\n\t//匿名内部类\n\tpublic static void main(String[] args) {\n\t\tSet<String> ts = new TreeSet<String>(new Comparator<Object>() {\n\t\t\tpublic int compare(Object o1,Object o2){\n\t\t\t\tString s1 = (String)o1;\n\t\t\t\tString s2 = (String)o2;\n\t\t\t\t//升序\n\t\t\t\t//return s1.compareTo(s2);\n\t\t\t\t//降序\n\t\t\t\treturn s2.compareTo(s1);\n\t\t\t}\n\t\t});\n\t\tts.add(\"HashSet\");\n\t\tts.add(\"ArrayList\");\n\t\tts.add(\"TreeMap\");\n\t\tts.add(\"HashMap\");\n\t\tts.add(\"TreeSet\");\n\t\tts.add(\"LinkedList\");\n\t\t//迭代器\n\t\tIterator<String> iter = ts.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tObject obj = iter.next();\n\t\t\tSystem.out.print(obj+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t//增强for循环\n\t\tfor(Object temp:ts){\n\t\t\tSystem.out.print(temp+\" \");\n\t\t}\n\t}\n}\n```\n\n* b)使用静态内部类实现    TreeSetTest1.java\n\n\n```\npublic class TreeSetTest1 {\n\tpublic static void main(String[] args) {\n\t\tTreeSet<String> ts = new TreeSet<String>(new MyComparator());   \n\t\tts.add(\"HashSet\");\n\t\tts.add(\"ArrayList\");\n\t\tts.add(\"TreeMap\");\n\t\tts.add(\"HashMap\");\n\t\tts.add(\"TreeSet\");\n\t\tts.add(\"LinkedList\");\n\t\t//使用迭代器遍历\n\t\tSystem.out.println(\"迭代器:\");\n\t\tIterator<String> iter = ts.iterator();\n\t\twhile(iter.hasNext()){\n\t\t\tObject obj = iter.next();\n\t\t\tSystem.out.print(obj+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"增强for循环:\");\n\t\t//使用增强for循环\n\t\tfor(Object temp:ts){\n\t\t\tSystem.out.print(temp+\" \");\n\t\t}\n\t}\n\t//静态内部类\n\tstatic class MyComparator implements Comparator<Object>{\n\t\tpublic int compare(Object o1, Object o2){\n\t\t\tString s1 = (String)o1;\n\t\t\tString s2 = (String)o2;\n\t\t\t//升序\n\t\t\treturn s1.compareTo(s2);\n\t\t\t//降序\n\t\t\t//return -s1.compareTo(s2);\n\t\t}\n\t}\n}\n```\n\n* 使用TreeSet和Comparator，写TreeSetTest2.java \n要求：对TreeSet中的元素1，2，3，4，5，6，7，8，9，10进行排列， \n排序逻辑为奇数在前偶数在后， 奇数按照升序排列，偶数按照降序排列\n\n```\npublic class TreeSetTest2 {\n\tpublic static void main(String[] args) {\n\t\t Set set = new TreeSet(new Comparator(){    //util包中\n\t\t\tpublic int compare(Object o1,Object o2){\n\t\t\t\tInteger i1 = (Integer)o1;\n\t\t\t\tInteger i2 = (Integer)o2;\n\t\t\t\tif(i2%2==0) return i2-i1;\n\t\t\t\treturn i1-i2;\n\t\t\t}\n\t\t});\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tset.add(i);\n\t\t}\n\t\tSystem.out.print(set);\n\t} \n\t\t\n\t\t/*TreeSet ts = new TreeSet(new MyComparator());\n\t\tfor (int i = 1; i <= 10; i++) {\n\t\t\tts.add(new Integer(i));\n\t\t}\n\t\t//迭代器\n\t\tIterator iter = ts.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tObject obj = iter.next();\n\t\t\tSystem.out.print(obj + \" \");\n\t\t}\n\t}*/\n}\n/*class MyComparator implements Comparator {\n\tpublic int compare(Object o1, Object o2) {\n\t\tint num1 = ((Integer) o1).intValue();\n\t\tint num2 = ((Integer) o2).intValue();\n\n\t\tint type1 = num1 % 2;\n\t\tint type2 = num2 % 2;\n\t\tif (type1 > type2)\n\t\t\treturn -1;\n\t\telse if (type1 < type2)\n\t\t\treturn 1;\n\t\telse {\n\t\t\tif (type1 == 0) {\n\t\t\t\tif (num1 > num2)\n\t\t\t\t\treturn -1;\n\t\t\t\telse if (num1 < num2)\n\t\t\t\t\treturn 1;\n\t\t\t} else if (type1 == 1) {\n\t\t\t\tif (num1 > num2)\n\t\t\t\t\treturn 1;\n\t\t\t\telse if (num1 < num2)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n}*/\n```\n\n* 测试java.util包下提供的TreeSet接口保存数据和数据的排序等\n\n```\npublic class Student implements Comparable{\n\tprivate String name;\n\tprivate int age;\n\tprivate String gender;\n\tpublic Student() {}\n\tpublic Student(String name, int age, String gender) {\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.gender = gender;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic String getGender() {\n\t\treturn gender;\n\t}\n\tpublic void setGender(String gender) {\n\t\tthis.gender = gender;\n\t};\n\t@Override\n\tpublic int hashCode(){\n\t\t//将会影响判断两个对象是否相等的属性的hashcode的值相加\n\t\treturn name.hashCode()+age+gender.hashCode();\n\t}\n\t@Override\n\tpublic boolean equals(Object obj){\n\t\tif(obj==null){\n\t\t\treturn false;\n\t\t}\n\t\tif(this==obj){\n\t\t\treturn true;\n\t\t}\n\t\tif(this.getClass()!=obj.getClass()){\n\t\t\treturn false;\n\t\t}\n\t\tif(obj instanceof Student){\n\t\t\tStudent s = (Student)obj;\n\t\t\tif(this.getName().equals(s.getName()) && this.getAge()==s.getAge() && this.getGender().equals(s.getGender()) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn name+\"-\"+age+\"-\"+gender;\n\t}\n\t@Override\n\tpublic int compareTo(Object o){\n\t\tif(o instanceof Student){\n\t\t\tStudent s = (Student)o;\n\t\t\tif(s.getAge()==getAge()){\n\t\t\t\treturn getName().compareTo(s.getName());\n\t\t\t}\n\t\t\treturn s.getAge()-this.getAge();\n\t\t}\n\t\treturn 0;\n\t}\n}\n```\n\n* 测试类\n\n```\nimport java.util.*;\n\n//自定义的数据类型,Set集合是如何判断是否相等\n//数据放到数据集合的哪个位置\npublic class StudentTest {\n\tpublic static void main(String[] args) {\n\t\t//Set set = new HashSet();\n\t\t//Set set = new TreeSet();\n\t\tSet set = new TreeSet(new Comparator(){\n\t\t\tpublic int compare(Object o1,Object o2){\n\t\t\t\tStudent s1 = (Student)o1;\n\t\t\t\tStudent s2 = (Student)o2;\n\t\t\t\treturn s1.getAge()-s2.getAge();\n\t\t\t}\n\t\t});\n\t\tStudent s1 = new Student(\"tom\",21,\"male\");\n\t\tStudent s2 = new Student(\"jack\",22,\"male\");\n\t\tStudent s3 = new Student(\"tucy\",22,\"male\");\n\t\tStudent s4 = new Student(\"lili\",20,\"male\");\n\t\tset.add(s1);\n\t\tset.add(s2);\n\t\tset.add(s3);\n\t\tset.add(s4);\n\t\tSystem.out.println(set.size());\n\t\tSystem.out.println(set);\n\t}\n}\n```\n\n* 默认是升序排序解决问题\n\n```\nimport java.util.*;\n\n@SuppressWarnings(\"all\")\npublic class Test {\n\tpublic static void main(String[] args) {\n\t\tSet set = new TreeSet(new Comparator(){    //util包中\n\t\t\tpublic int compare(Object o1,Object o2){\n\t\t\t\tInteger i1 = (Integer)o1;\n\t\t\t\tInteger i2 = (Integer)o2;\n\t\t\t\tif(i2%2==0) return i2-i1;\n\t\t\t\treturn i1-i2;\n\t\t\t}\n\t\t});\n\t\tfor(int i=1;i<=10;i++){\n\t\t\tset.add(i);\n\t\t}\n\t\tSystem.out.print(set);\n\t}\n}\n//[1, 3, 5, 7, 9, 10, 8, 6, 4, 2]\n\n\nimport java.util.*;\n@SuppressWarnings(\"all\")\npublic class TreeSetTest {\n\tpublic static void main(String[] args) {\n\t\tSet set = new TreeSet(\n\t\t\t\tnew Comparator() {\n\t\t\t\t\tpublic int compare(Object o1,Object o2) {  //覆盖排序\n\t\t\t\t\t\tString s1=(String)o1;\n\t\t\t\t\t\tString s2=(String)o2;\n\t\t\t\t\t\treturn s2.compareTo(s1);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\tset.add(\"b\");\n\t\tset.add(\"a\");\n\t\tset.add(\"d\");\n\t\tset.add(\"c\");\n\t\tSystem.out.println(set);   //String类默认是升序排列，如果要降序排列就要用覆盖排序\n\t}\n}\n\n```\n\n\n\n\n\n","categories":["corejava"]},{"title":"用集合实现队列和栈","url":"/2019/08/25/corejava_QueueAndStackUseList/","content":"\n## 使用ArrayList实现队列和栈\n\n* 实现队列功能\n\n```\npublic class MyQueue {\n\tprivate ArrayList data;\n\tpublic MyQueue(){\n\t\tdata = new ArrayList();\t\t\n\t}\n\tpublic void in(Object o){\n\t\tdata.add(o);\n\t}\n\tpublic Object out(){\n\t\tint size = data.size();\n\t\tif(size>0)\n\t\t\treturn data.remove(0);\n\t\telse \n\t\t\treturn null;\n\t}\n\tpublic int getSize(){\n\t\treturn data.size();\n\t}\n}\n```\n\n* 实现栈功能\n\n```\npublic class MyStack {\n\tprivate ArrayList data;\n\tpublic MyStack() {\n\t\tdata = new ArrayList();\n\t}\n\tpublic void push(Object o) {\n\t\tdata.add(o);\n\t}\n\tpublic Object pop() {\n\t\tint size = data.size();\n\t\tif (size > 0)\n\t\t\treturn data.remove(data.size() - 1);\n\t\telse\n\t\t\treturn null;\n\t}\n\tpublic int getSize() {\n\t\treturn data.size();\n\t}\n}\n```\n\n* 测试类\n\n```\npublic class QueueAndStackTest \n{\n\tpublic static void main(String[] args) \n\t{\n\t\t//栈\n\t\tSystem.out.println(\"栈测试......\");\n\t\tMyStack stack = new MyStack();\n\t\tstack.push(1);\n\t\tstack.push(new Integer(2));\n\t\tstack.push(new Integer(3));\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tstack.push(new Integer(4));\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tstack.push(new Integer(5));\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tSystem.out.print(stack.pop()+\" \");\n\t\tSystem.out.println();\n\t\t\n\t\t//队列\n\t\tSystem.out.println(\"队列测试......\");\n\t\tMyQueue queue = new MyQueue();\n\t\tqueue.in(new Integer(1));\n\t\tqueue.in(new Integer(2));\n\t\tqueue.in(new Integer(3));\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tqueue.in(new Integer(4));\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tqueue.in(new Integer(5));\n\t\tSystem.out.print(queue.out()+\" \");\n\t\tSystem.out.print(queue.out()+\" \");\n\t}\n}\n```\n\n","categories":["corejava"]},{"title":"Map集合排序问题","url":"/2019/08/25/corejava_map/","content":"\n## Map集合排序问题\n\n* 使用Map集合保存数据，其key为Student对象，其Value是Address对象，Address类中包含city,country,street属性。a)如何保证添加的Student对象是唯一的b)对其进行排序，按照Student的年龄进行升序排序，如果Student的年龄相同按照名字进行升序排序。\n\n* 地址类\n\n```\npublic class Address {\n\tprivate String country;\n\tprivate String city;\n\tprivate String street;\n\tpublic Address(String country, String city, String street) {\n\t\tsuper();\n\t\tthis.country = country;\n\t\tthis.city = city;\n\t\tthis.street = street;\n\t}\n\tpublic String getCountry() {\n\t\treturn country;\n\t}\n\tpublic void setCountry(String country) {\n\t\tthis.country = country;\n\t}\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\tpublic void setCity(String city) {\n\t\tthis.city = city;\n\t}\n\tpublic String getStreet() {\n\t\treturn street;\n\t}\n\tpublic void setStreet(String street) {\n\t\tthis.street = street;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn country + \"-\" + city + \"-\"+ street;\n\t}\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Address){\n\t\t\tAddress address = (Address)o;\n\t\t\tif(address.getCountry().equals(country)&&address.getCity().equals(city)&&address.getStreet().equals(street))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int hashCode(){\n\t\treturn country.hashCode()+city.hashCode()+street.hashCode();\n\t}\n}\n```\n\n* 学生类\n\n```\npublic class Student{ //implements Comparable<Object>{\n\tprivate String name;\n\tprivate int age;\n\tprivate String gender;\n\tpublic Student(String name, int age, String gender) {\n\t\tsuper();\n\t\tthis.name = name;\n\t\tthis.age = age;\n\t\tthis.gender = gender;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n\tpublic String getGender() {\n\t\treturn gender;\n\t}\n\tpublic void setGender(String gender) {\n\t\tthis.gender = gender;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn name + \"-\" + age + \"-\" + gender;\n\t}\n\t@Override\n\tpublic boolean equals(Object o){\n\t\tif(o instanceof Student){\n\t\t\tStudent stu = (Student)o;\n\t\t\tif(stu.getName().equals(name)&&stu.getAge()==age&&stu.getGender().equals(gender))\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t@Override\n\tpublic int hashCode(){\n\t\treturn name.hashCode()+age+gender.hashCode();\n\t}\n\t/*@Override\n\tpublic int compareTo(Object o) {\n\t\tif(o instanceof Student){\n\t\t\tStudent stu = (Student)o;\n\t\t\tif(this.getAge()==stu.getAge()){\n\t\t\t\treturn getName().compareTo(stu.getName());\n\t\t\t}\n\t\t\treturn this.getAge()-stu.getAge();\n\t\t}\n\t\treturn 0;\n\t}*/\n}\n```\n\n* 测试类\n\n```\n//测试\npublic class TreeMapTest {\n\tpublic static void main(String[] args) {\n\t\tTreeMap<Student, Address> hm = new TreeMap<>(new Comparator<Object>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Object o1, Object o2) {\n\t\t\t\tStudent s1 = (Student)o1;\n\t\t\t\tStudent s2 = (Student)o2;\n\t\t\t\tif(s1.getAge()==s2.getAge()){\n\t\t\t\t\treturn s1.getName().compareTo(s2.getName());\n\t\t\t\t}\n\t\t\t\treturn s1.getAge()-s2.getAge();\n\t\t\t}\n\t\t});\n\t\thm.put(new Student(\"一号\", 10, \"男\"), new Address(\"中国\", \"江苏\", \"学院路\"));\n\t\thm.put(new Student(\"三号\", 30, \"女\"), new Address(\"中国\", \"上海\", \"步行街\"));\n\t\thm.put(new Student(\"二号\", 20, \"男\"), new Address(\"中国\", \"江苏\", \"步行街\"));\n\t\thm.put(new Student(\"四号\", 20, \"女\"), new Address(\"中国\", \"上海\", \"学院路\"));\n\t\thm.put(new Student(\"二号\", 20, \"男\"), new Address(\"中国\", \"江苏\", \"步行街\"));\n\t\t// System.out.println(hm);\n\t\tprint1(hm);\n\t\tprint2(hm);\n\t}\n\tpublic static void print1(TreeMap<Student, Address> hm) {\n\t\t// keySet\n\t\tSet<Student> keys = hm.keySet();\n\t\tfor (Student key : keys) {\n\t\t\tAddress value = hm.get(key);\n\t\t\tSystem.out.println(key + \"+\" + value);\n\t\t}\n\t}\n\tpublic static void print2(TreeMap<Student, Address> hm) {\n\t\t// entrySet\n\t\tSet<Map.Entry<Student, Address>> kv = hm.entrySet();\n\t\tIterator<Map.Entry<Student, Address>> iter = kv.iterator();\n\t\twhile (iter.hasNext()) {\n\t\t\tMap.Entry<Student, Address> entry = iter.next();\n\t\t\tStudent k = entry.getKey();\n\t\t\tAddress v = entry.getValue();\n\t\t\tSystem.out.println(k + \"++\" + v);\n\t\t}\n\t}\n\t/*public static void print3(HashMap<Student, Address> hm) {\n\t\tSet set = hm.entrySet();\n\t\tIterator iterator = set.iterator();\n\t\twhile (iterator.hasNext()) {\n\t\t\tSystem.out.println(iterator.next());\n\t\t}\n\t}*/\n\n}\n```\n\n\n\n\n","categories":["corejava"]},{"title":"java排序","url":"/2019/08/22/corejava_paiXu/","content":"\n## java排序问题\n\n**冒泡排序**\n\n* 冒泡排序： 对两个相邻的数据进行比较，如果前一个数据比后一个数据大，就交换位置，最多执行length-1趟比较，每趟比较的次数最length-i-1\n\n```\n//冒泡排序\n\tpublic static int[] sortByMaoPao(int[] array){\n\t\tfor(int i=0;i<array.length-1;i++){   //控制趟数\n\t\t\tfor(int j=0;j<array.length-i-1;j++){   //\n\t\t\t\tif((array[j]>array[j+1])){\n\t\t\t\t\t//交换两个数\n\t\t\t\t\tint temp = array[j];\n\t\t\t\t\tarray[j] = array[j+1];\n\t\t\t\t\tarray[j+1] = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn array;\n\t}\n```\n\n**选择排序**\n\n* 选择排序：每次把比较的第一个个数当做是最小数，如果找到后面有比自己小的数，就记录位置，比较完之后交换这两个数的位置。\n\n```\n//选择排序\n\tpublic static void sortByXuanze(int[] array){\n\t\tfor(int i=0;i<array.length-1;i++){\n\t\t\tint k=i;  //最小数位置\n\t\t\tfor(int j=i+1;j<array.length;j++){\n\t\t\t\tif(array[k]>array[j]){\n\t\t\t\t\tk=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//交换数据\n\t\t\tint temp = array[i];\n\t\t\tarray[i] = array[k];\n\t\t\tarray[k] = temp; \n\t\t}\n\t}\n```\n\n**插入排序**\n\n* 插入排序:Insertion.java 增量法,排序过程的某一中间时刻，R被划分成两个子区间R[1．．i-1]（已排好序的有序区）和R[i．．n]（当前未排序的部分，可称无序区）。插入排序的基本操作是将当前无序区的第1个记录R[i]插人到有序区R[1．．i-1]中适当的位置上，使R[1．．i]变为新的有序区。因为这种方法每次使有序区增加1个记录，通常称增量法。插入排序与打扑克时整理手上的牌非常类似。摸来的第1张牌无须整理，此后每次从桌上的牌(无序区)中摸最上面的1张并插入左手的牌(有序区)中正确的位置上。为了找到这个正确的位置，须自左向右(或自右向左)将摸来的牌与左手中已有的牌逐一比较。\n\n```\n//插入排序\n\tpublic static void printByInsertion(int[] array){\n\t\tfor(int i=1;i<array.length;i++) {\n\t\t\tint value=array[i];\n\t\t\tint j=i-1;\n\t\t\twhile(j>=0) {\n\t\t\t\tif(array[j]>value) {\n\t\t\t\t\tarray[j+1]=array[j];\n\t\t\t\t}else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tarray[j+1]=value;\n\t\t}\n\t}\n```\n\n**输出方法**\n\n```\n//输出\n\tpublic static void print(int[] array){\n\t\tfor(int i=0;i<array.length;i++){\n\t\t\tSystem.out.print(array[i]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n```\n\n\n\n","tags":["数组"],"categories":["corejava"]},{"title":"数组模拟队列","url":"/2019/08/22/corejava_shuZuDuiLie/","content":"\n## 使用数组模拟队列\n\n```\n//使用数组模拟队列\npublic class Queue {\n\t\n\tprivate int[] array;  //队列\n\tprivate int length;   //队列总长度\n\tprivate int size;     //当前排队的长度\n\t\n\t//构造器------创建默认长度的队列\n\tpublic Queue(){\n\t\tthis(10);\n\t}\n\t//构造器------创建指定长度的队列\n\tpublic Queue(int length){\n\t\tarray = new int[length];\n\t\tthis.length = length;\n\t}\n\t\n\t//检查数组是否满了，满了扩充\n\tprivate void check(){\n\t\tif(size>=length){\n\t\t\tint[] nArray = new int[length+5];\n\t\t\tSystem.arraycopy(array, 0, nArray, 0, length);\n\t\t\tarray = nArray;\n\t\t\tthis.length +=5;\n\t\t}\n\t}\n\t\n\t//插队\n\tpublic void add(int value,int index){\n\t\tcheck();\n\t\tif(index<0||index>size){\n\t\t\tSystem.out.println(\"插入的位置不对\");\n\t\t\treturn;\n\t\t}\n\t\t/*for(int i=size;i>index;i--){\n\t\t\tarray[i] = array[i-1];\n\t\t}*/\n\t\tSystem.arraycopy(array, index, array, index+1, size-index);\n\t\tarray[index] = value;\n\t\tsize++;\n\t}\n\t\n\t//入队(添加一个数据）\n\tpublic void add(int value){\n\t\t/*if(size>=length){\n\t\t\tSystem.out.println(\"当前队列已满\");\n\t\t\treturn;\n\t\t}*/\n\t\tcheck();\n\t\tarray[size] = value;\n\t\tsize++;  //当前排队人数加加\n\t}\n\t\n\t//出队（删除一个数据）\n\tpublic int remove(){\n\t\tif(size<=0){\n\t\t\tSystem.out.println(\"当前队列没有数据\");\n\t\t\treturn 0;\n\t\t}\n\t\tint result = array[0];\n\t\t/*for(int i=0;i<size-1;i++){\n\t\t\tarray[i] = array[i+1];\n\t\t}*/\n\t\tSystem.arraycopy(array, 1, array, 0, size-1);\n\t\tarray[--size] = 0;\n\t\treturn result;\n\t}\n\t\n\t//当前队列长度\n\tpublic int size(){\n\t\treturn size;\n\t}\n\t\n\t//输出队列情况\n\tpublic void print(){\n\t\tSystem.out.print(\"当前队列为：\");\n\t\tfor(int i=0;i<size;i++){\n\t\t\tSystem.out.print(array[i]+\" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}\n```\n\n","categories":["corejava"]},{"title":"java基础编程题","url":"/2019/08/21/corejava_basic/","content":"\n##Java基础编程题 \n\n**传入一个int数，要求清除该数的低8位，高24位不变，将结果以十进制形式输出**\n\n```\npublic static int removeNum(int n){\n\t\treturn n & ~255;\n\t}\n```\n\n**传入一个int数，要求将该数的低16位置1，高16位不变，将结果以十进制形式输出**\n\n```\npublic static int resetNum(int n){\n\t\treturn n | 65535;\n\t}\n```\n\n**实现两个int类型变量值的交换，要求不使用中间变量**\n\n```\npublic static void changeLocate(int m,int n){\n\t\tSystem.out.println(\"两个数交换之前为：\"+m+\" \"+n);\n\t\tm = m ^ n;    //a = a+b;b = a-b;a=a-b;\n\t\tn = m ^ n;\n\t\tm = m ^ n;\n\t\tSystem.out.println(\"两个数交换之后为：\"+m+\" \"+n);\n\t}\n```\n\n**以二进制形式输出一个十进制数**\n\n```\npublic static void print(int num){\n\t\tSystem.out.print(num+\"的二进制位:\\t\");\n\t\tfor(int i=31;i>=0;i--){\n\t\t\tSystem.out.print(num>>i & 1);\n\t\t}\n\t\tSystem.out.println(); //换行\n\t}\n```\n\n```\n//任意位置1\n\tpublic static int bitSet(int num,int index){\n\t\treturn num | 1 << (index-1);\n\t}\n\t\n\t//任意位清0\n\tpublic static int bitZero(int num,int index){\n\t\treturn num & ~(1 << (index-1));\n\t}\n\t\n\t//任意位 置反\n\tpublic static int bitReverse(int num,int index){\n\t\treturn num ^ (1 << (index-1));\n\t}\n```\n\n**有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。**\n\n```\npublic static void printThreeNum(){\n\t\tint count = 0;\n\t\tint num = 0;\n\t\tfor(int i=1;i<=4;i++){\n\t\t\tfor(int j=1;j<=4;j++){\n\t\t\t\tfor(int k=1;k<=4;k++){\n\t\t\t\t\tif(i!=j&&j!=k&&k!=i){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tnum = i*100+j*10+k;\n\t\t\t\t\t\tSystem.out.print(num+\" \");\n\t\t\t\t\t\tif(count%10==0){\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"总数：\"+count);\n\t}\n```\n\n**用递归的方式实现功能：一个数X 的阶乘（通常记作X!）等于X*(X-1)*(X-2)*.....*1**\n\n```\npublic static int printByDigui(int num){\n\t\tif(num==0){\n\t\t\treturn 1;\n\t\t}else {\n\t\t\treturn num*printByDigui(num-1);\n\t\t}\n\t}\n```\n\n**将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：a)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。b) 如果n不等于i，i能被n整除，则应打印出i的值，并用n除以i的商,作为新的正整数n,重复执行第一步。提示：如果一个自然数能写成两个自然数的乘积，那么这两个自然数就叫作原来那个数的因数。**\n\n```\npublic static void resolveNum(int num){\n\t\tfor(int i=2;i<=num;i++){\n\t\t\tif(num%i==0){\n\t\t\t\tSystem.out.print(i+\"*\");\n\t\t\t\tnum = num/i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(num);\n\t}\n\t\n\tpublic static void resolveNum2(int num){\n\t\tint i = 2;\n\t\twhile(num>i){\n\t\t\tif(num%i==0){\n\t\t\t\tSystem.out.print(i+\"*\");\n\t\t\t\tnum = num/i;\n\t\t\t}else{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(num+\";\");\n\t}\n```\n\n**求任意两个正整数的最大公约数和(GCD)和最小公倍数(LCM).辗转相除法的算法为：首先将 m除以 n（m>n）得余数 r，再用余数  r 去除原来的除数，得新的余数，重复此过程直到余数为 0时停止， 此时的除数就是m 和 n的最大公约数。 求 m和 n的最小公倍数: m和 n的积除以(m和 n 的最大公约数)。**\n\n```\npublic static int printGCD(int num1,int num2){\n\t\tif(num1<num2){\n\t\t\tnum1 = num1 + num2;\n\t\t\tnum2 = num1 - num2;\n\t\t\tnum1 = num1 - num2;\n\t\t}\n\t\tint r = num1%num2;\n\t\tif(r!=0){\n\t\t\tnum1 = num2;\n\t\t\tnum2 = r;\n\t\t\tr = num1%num2;\n\t\t}\n\t\treturn num2;\n\t}\n\t\n\tpublic static int printLCM(int num1,int num2){\n\t\tint gcd = printGCD(num1, num2);\n\t\tint lcm = num1*num2/gcd;\n\t\treturn lcm;\n\t}\n```\n\n**九九乘法表**\n\n```\npublic static void printZuoXia(){\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printZuoShang(){\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printYouXia(){\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tfor(int k=1;k<=9-i;k++){\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printYouShang(){\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tfor(int k=1;k<=9-i;k++){\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n```\n\n**求1000以内的完全数,若一个自然数，恰好与除去它本身以外的一切因数的和相等，这种数叫做完全数。例如，6=1+2＋3,28=1＋2＋4＋7＋14,496=1+2+4+8＋16+31+62＋124.先计算所选取的整数a(a的取值1~1000)的因数，将各因数累加于m，若m等于a，则可确认a为完全数**\n\n```\npublic static void main(String[] args) {\n\t\tSystem.out.println(\"1000以内完全数有：\");\n\t\tfor(int i = 1;i<=1000;i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=1;j<=i/2;j++){\n\t\t\t\tif(i%j==0){\n\t\t\t\t\tsum+=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum==i){\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t}\n```\n\n**判断101-200之间有多少个素数，并输出所有素数。只能被1和它本身整除的自然数为素数(质数)**\n\n```\npublic static void printPrime() {\n\t\tint count = 0;\n\t\tfor (int i = 101; i <= 200; i++) {\n\t\t\tboolean isPrime = true;\n\t\t\tfor (int j = 2; j < i; j++) {\n\t\t\t\tif (i % j == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPrime){\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"总共有\"+count+\"个素数\");\n\t}\n```\n\n","categories":["corejava"]},{"title":"网络编程","url":"/2019/07/22/corejava_net/","content":"\n## 基于TCP的Socket编程步骤：\n+ 套接字socket：代表通信节点\n\t- 实质：一种独立于协议的网络编程接口。\n\t* 作用：完成两个应用程序之间的数据传输。\n\t+ 类型：流式套接字、数据报套接字、原始套接字。\n1. **服务器程序编写：**\n\t* ①调用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上；\n\t* ②调用accept()，监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字；\n\t* ③调用Socket类的getInputStream和getOutputStream()获取输入流和输出流，开始网络数据的接收和发送；\n\t* ④最后关闭通信套接字。\n2. **客户端程序编写：**\n\t* ①调用Socket()创建一个流套接字，并连接到服务器端； \n\t* ②调用Socket类的getOutputStream()和getInputStream获取输出流和输入流，开始网络数据的发送和接收； \n\t* ③最后关闭通信套接字。\n\n---\n\n**服务端和客户端简单交互**\n\n服务端：\n\n```java\n//基于TCP协议的服务端\npublic class TcpServer {\n\tpublic static void main(String[] args) {\n\t\tServerSocket ss = null;  //声明\n\t\tBufferedReader br = null;\n\t\tPrintWriter pw = null;\n\t\tSocket socket = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建ServerSocket对象\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经在9999端口启动！\");\n\t\t\twhile(true){\n\t\t\t\t//2.监听连接请求，等待客户端请求连接\n\t\t\t\tsocket = ss.accept();  //阻塞作用\n\t\t\t\t//3.基于Socket对象读写数据\n\t\t\t\t//读客户端发来的数据\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t\t//给客户端发出数据\n\t\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\t\tpw.println(new Date().toString());\n\t\t\t\tpw.flush();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\t//关闭资源(先开后关)\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(socket!=null)\tsocket.close();\n\t\t\t\tif(ss!=null)\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n```java\n//基于TCP协议的服务器端，使用多线程\npublic class TcpServer2 {\n\tprivate ServerSocket ss;\n\t\n\tpublic TcpServer2() {\n\t\ttry {\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经启动....\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\t//每来一个客户端就启动一个线程来单独处理该客户端和服务端的通信\n\t\t\t\tnew ServerThread(socket).start();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew TcpServer2();\n\t}\n}\nclass ServerThread extends Thread{\n\tprivate Socket socket;\n\t\n\tpublic ServerThread(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t@Override\n\tpublic void run(){\n\t\t//3.基于Socket对象读写数据\n\t\t//读客户端发来的数据\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t//给客户端发出数据\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(new Date().toString());\n\t\t\tpw.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\n//基于TCP的客户端\npublic class TcpClient {\n\tpublic static void main(String[] args) {\n\t\tSocket socket = null;\n\t\tPrintWriter pw = null;\n\t\tBufferedReader br = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建Socket对象，并绑定IP地址和端口号\n\t\t\tsocket = new Socket(\"127.0.0.1\",9999);\n\t\t\t//2.基于Socket的读写数据\n\t\t\t//客户端给服务端写数据\n\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(\"请给我你的时间！\");\n\t\t\tpw.flush();\n\t\t\t//接受服务器发来的数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString time = br.readLine();\n\t\t\tSystem.out.println(\"时间为：\"+time);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(socket!=null) \tsocket.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n---\n\n**聊天室模拟**\n\n服务端：\n\n```java\n//聊天室的服务端\npublic class ChatServer {\n\tprivate ServerSocket ss;\n\tprivate Set<Socket> clients;\n\t\n\tpublic ChatServer(){\n\t\ttry {\n\t\t\tss = new ServerSocket(8888);\n\t\t\tclients = new HashSet<Socket>();\n\t\t\tSystem.out.println(\"聊天室的服务器端已经启动...\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\tclients.add(socket);\n\t\t\t\t//启动一个线程单独处理该客户端\n\t\t\t\tnew ChatThread(socket,clients).start();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew ChatServer();\n\t}\n}\n\n//接收客户端的数据并转发给所有的客户端\nclass ChatThread extends Thread{\n\tprivate Socket currentSocket;  //当前客户端\n\tprivate Set<Socket> clients;\n\tpublic ChatThread(Socket currentSocket,Set<Socket> clients) {\n\t\tthis.currentSocket = currentSocket;\n\t\tthis.clients = clients;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\t//读数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(currentSocket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//转发给所有的客户端\n\t\t\t\tfor(Socket client:clients){\n\t\t\t\t\tPrintWriter pw = new PrintWriter(client.getOutputStream());\n\t\t\t\t\tpw.println(str);\n\t\t\t\t\tpw.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class ChatClient extends JFrame {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate JTextArea sendArea;//要发送信息的内容区域\n\tprivate JTextArea contentArea;//聊天记录的内容区域\n\tprivate Container contentPane;\n\tprivate String name;//当前用户名\n\tprivate Socket socket;\n\t\n\tpublic static void main(String[] args) throws UnknownHostException, IOException {\n\t\tSocket socket = new Socket(\"127.0.0.1\",8888);\n\t\tnew ChatClient(\"张三\",socket).go();\n\t}\n\tpublic ChatClient(String name,Socket socket){\n\t\tthis.name = name;\n\t\tthis.socket = socket;\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tinitGUI();\n\t\t//启动一个子线程，专门接收服务器端传来的数据\n\t\tnew ClientThread(socket,contentArea).start();\n\t}\n\tpublic void initGUI(){\n\t\tthis.setSize(300,400);\n\t\tthis.setTitle(\"我的聊天室\");\n\t\tcontentPane = getContentPane();\n\t\tint x = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();\n\t\tint y = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();\n\t\tthis.setLocation((x-this.getWidth())/2, (y-this.getHeight())/2);\n\t\tthis.setResizable(false);\n\t\t\n\t\tcontentArea = new JTextArea();\n\t\tcontentArea.setEditable(false);\n\t\tJScrollPane logPanel = new JScrollPane(contentArea,\n\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tsendArea = new  JTextArea();\n\t\tsendArea.addKeyListener(new KeyAdapter() {\n\t\t\t public void keyPressed(KeyEvent e) {\n\t\t\t\t if(e.getKeyCode()==KeyEvent.VK_ENTER){\n\t\t\t\t\t send();\n\t\t\t\t }\n\t\t\t }\n\t\t});\n\t\tJScrollPane sendPanel = new JScrollPane(sendArea,\n\t\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t//创建一个分割窗口\n\t\tJSplitPane splitPane = new JSplitPane(\n\t\t\t\tJSplitPane.VERTICAL_SPLIT,logPanel,sendPanel);\n\t\tsplitPane.setDividerLocation(250);\n\t\tcontentPane.add(splitPane,BorderLayout.CENTER);\n\t\t\n\t\t//下面的\n\t\tJPanel jp = new JPanel();\n\t\tjp.setLayout(new FlowLayout(FlowLayout.RIGHT));\n\t\tcontentPane.add(jp,BorderLayout.SOUTH);\n\t\t\n\t\tJLabel nameLbl = new JLabel(\"用户名：\"+this.name+\" \");\n\t\tjp.add(nameLbl);\n\t\t\n\t\tJButton resetBtn = new JButton(\"close\");\n\t\tresetBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t});\n\t\tjp.add(resetBtn);\n\t\t\n\t\tJButton sendBtn = new JButton(\"send\");\n\t\tjp.add(sendBtn);\n\t\tsendBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tsend();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void go(){\n\t\tthis.setVisible(true);\n\t}\n\tpublic void send (){\n\t\t//获取要发送的信息\n\t\tString msg = sendArea.getText();\n\t\tSimpleDateFormat formater = new SimpleDateFormat(\"HH:mm:ss\");\n\t\tString date = formater.format(new Date());\n\t\tString sendStr = name+\" \"+date+\"说： \"+msg;\n\t\t\n\t\ttry {\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\t//发送数据给服务器\n\t\t\tpw.println(sendStr);\n\t\t\tpw.flush();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t//contentArea.append(sendStr+\"\\n\");\n\t\tsendArea.setText(\"\");\n\t}\n}\n\n//接收服务器端的数据，并显示在界面上\nclass ClientThread extends Thread{\n\tprivate Socket socket;\n\tprivate JTextArea contentArea;\n\t\n\tpublic ClientThread(Socket socket,JTextArea contentArea){\n\t\tthis.socket = socket;\n\t\tthis.contentArea = contentArea;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//显示在界面上\n\t\t\t\tcontentArea.append(str+\"\\n\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n---\n\n## 基于UDP的Socket编程步骤：\n1. **服务器端基于UDP编程：**\n\t- a) 调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上；\n\t- b) 调用DatagramPacket(byte[] buf, int length)，建立一个字节数组以接收客户端的UDP包 ；\n\t- c) 调用DatagramSocket类的receive()，接收客户端的UDP包并放在上一步创建的数据包中；通过调用DatagramPacket的getData获取数据。\n\t- d) 创建数据包，用来存放发送给客户端响应数据。\n```\n\tint port = dp.getPort();\n\tInetAddress address=dp.getAddress();\n\tString msg=new Date().toString();\n\tbuf=msg.getBytes();\n\tDatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port);\n```\n\t- e) 向客户端发送数据包DatagramSocket.send(DatagramPacket)\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n2. **客户端程序编写：**\n\t- a) 调用DatagramSocket()创建一个数据报套接字。 \n\t- b) 调用DatagramPacket(byte[] buf, int length, InetAddress address, int port)，建立要发送的UDP包；\n\t\t包含发给服务器的数据，服务器地址，服务器的端口。\n\t- c) 调用DatagramSocket类的send(dp)，发送UDP包；\n\t- d) 创建数据包，用来存放服务器端返回响应数据。\n```\n\t\t   DatagramPacket dp1=new DatagramPacket(buf,buf.length);\n```\n\t- e) 接收服务器端响应数据ds.receive(dp1);\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n\n---\n\n**UDP服务端客户端简单交互**\n\n服务端：\n\n```java\n//基于UDP协议的服务端\npublic class UDPServer {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//1.创建DatagramSocket对象，并绑定端口号\n\t\tDatagramSocket ds = new DatagramSocket(8899);\n\t\tSystem.out.println(\"服务器端已经在8899端口启动......\");\n\t\t//2.接收数据包\n\t\tbyte[] buf = new byte[2048];  //存放数据\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp);//有阻塞功能\n\t\t//3.输出数据包中内容\n\t\tString str = new String(dp.getData());\n\t\tSystem.out.println(\"接收到客户端数据为：\"+str);\n\t\t\n\t\t//4.发送数据包(内容，客户端IP和port\n\t\tString message = new Date().toString();\n\t\tbuf = message.getBytes();  //需要发送的数据\n\t\tint port = dp.getPort();  //获取客户端的端口号\n\t\tInetAddress address = dp.getAddress(); //客户端IP地址\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length, address, port);\n\t\tds.send(dp1);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class UDPClient {\n\tpublic static void main(String[] args) throws Exception{\n\t\t//1.创建DatagramSocket对象，绑定IP地址和端口号\n\t\tDatagramSocket ds = new DatagramSocket();\n\t\t//2.发送数据包\n\t\tbyte[] buf = new byte[2048];\n\t\tbuf = \"give me your time\".getBytes();\n\t\tInetAddress address = InetAddress.getByName(\"127.0.0.1\");  //根据主机名获取InetAddress对象\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length,address,8899);\n\t\tds.send(dp);\n\t\t//3.接收数据包\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp1);\n\t\t//输出数据包数据\n\t\tString message = new String(dp1.getData());\n\t\tSystem.out.println(\"接收服务器端数据:\"+message);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n\n","tags":["java基础"],"categories":["corejava"]},{"title":"IO流","url":"/2019/07/15/io/","content":"# 第七章 IO流\n## 一、流的概念\n+ Java中流是使用统一的方式操作输入和输出的数据。\n+ java.io包它对各种常见的输入流和输出流进行了抽象。\n## 二、流的分类\n1. 流操作的方向（参照物：当前程序）\n   + **输入流**：将数据读取到程序中。\n   + **输出流**：将程序中的数据写出到文件中。\n2. 类操作的最小数据单元\n   + **字节类**：如果数据流中最小的数据单元是字节，那么称这种流为字节流。字节流处理单元为 1 个字节，可以操作字节和字节数组。\n   + **字符类**：如果数据流中最小的数据单元是字符，那么称这种流为字符流。字符流处理的单元为 2 个字节的 Unicode 字符，可以操作字符、字符数组或字符串。Java内用Unicode 编码存储字符,字符流处理类负责将外部的其他编码的字符流和java内Unicode 字符流之间的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。\n3. 流的角色\n   + **字节流**：处理实际数据源，上述四种都是属于字节流。如*FileInputStream*。\n   + **处理流/包装流**:处理包装的流。如*BufferedInputStream*。\n## 三、几种重要的流\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;\n1. 所有字节输入流和字节输出流的父类：\n   + java.io.InputStream\n   + java.io.OutputStream\n2. 文件字节流:\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;","tags":["java基础"],"categories":["corejava"]},{"title":"Hello World","url":"/2019/06/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]