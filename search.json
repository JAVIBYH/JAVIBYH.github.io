[{"title":"java基础编程题","url":"/2019/08/21/corejava_basic/","content":"\n#Java基础编程题 \n\n** 传入一个int数，要求清除该数的低8位，高24位不变，将结果以十进制形式输出 **\n\n```\npublic static int removeNum(int n){\n\t\treturn n & ~255;\n\t}\n```\n\n** 传入一个int数，要求将该数的低16位置1，高16位不变，将结果以十进制形式输出 **\n\n```\npublic static int resetNum(int n){\n\t\treturn n | 65535;\n\t}\n```\n\n** 实现两个int类型变量值的交换，要求不使用中间变量 **\n\n```\npublic static void changeLocate(int m,int n){\n\t\tSystem.out.println(\"两个数交换之前为：\"+m+\" \"+n);\n\t\tm = m ^ n;    //a = a+b;b = a-b;a=a-b;\n\t\tn = m ^ n;\n\t\tm = m ^ n;\n\t\tSystem.out.println(\"两个数交换之后为：\"+m+\" \"+n);\n\t}\n```\n\n** 以二进制形式输出一个十进制数 **\n\n```\npublic static void print(int num){\n\t\tSystem.out.print(num+\"的二进制位:\\t\");\n\t\tfor(int i=31;i>=0;i--){\n\t\t\tSystem.out.print(num>>i & 1);\n\t\t}\n\t\tSystem.out.println(); //换行\n\t}\n```\n\n```\n//任意位置1\n\tpublic static int bitSet(int num,int index){\n\t\treturn num | 1 << (index-1);\n\t}\n\t\n\t//任意位清0\n\tpublic static int bitZero(int num,int index){\n\t\treturn num & ~(1 << (index-1));\n\t}\n\t\n\t//任意位 置反\n\tpublic static int bitReverse(int num,int index){\n\t\treturn num ^ (1 << (index-1));\n\t}\n```\n\n** 有1、2、3、4个数字，能组成多少个互不相同且无重复数字的三位数？都是多少？程序分析：可填在百位、十位、个位的数字都是1、2、3、4。组成所有的排列后再去掉不满足条件的排列。**\n\n```\npublic static void printThreeNum(){\n\t\tint count = 0;\n\t\tint num = 0;\n\t\tfor(int i=1;i<=4;i++){\n\t\t\tfor(int j=1;j<=4;j++){\n\t\t\t\tfor(int k=1;k<=4;k++){\n\t\t\t\t\tif(i!=j&&j!=k&&k!=i){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t\tnum = i*100+j*10+k;\n\t\t\t\t\t\tSystem.out.print(num+\" \");\n\t\t\t\t\t\tif(count%10==0){\n\t\t\t\t\t\t\tSystem.out.println();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"总数：\"+count);\n\t}\n```\n\n**　用递归的方式实现功能：一个数X 的阶乘（通常记作X!）等于X*(X-1)*(X-2)*.....*1　**\n\n```\npublic static int printByDigui(int num){\n\t\tif(num==0){\n\t\t\treturn 1;\n\t\t}else {\n\t\t\treturn num*printByDigui(num-1);\n\t\t}\n\t}\n```\n\n** 将一个正整数分解质因数。例如：输入90,打印出90=2*3*3*5。对n进行分解质因数，应先找到一个最小的质数k，然后按下述步骤完成：a)如果这个质数恰等于n，则说明分解质因数的过程已经结束，打印出即可。b) 如果n不等于i，i能被n整除，则应打印出i的值，并用n除以i的商,作为新的正整数n,重复执行第一步。提示：如果一个自然数能写成两个自然数的乘积，那么这两个自然数就叫作原来那个数的因数。**\n\n```\npublic static void resolveNum(int num){\n\t\tfor(int i=2;i<=num;i++){\n\t\t\tif(num%i==0){\n\t\t\t\tSystem.out.print(i+\"*\");\n\t\t\t\tnum = num/i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(num);\n\t}\n\t\n\tpublic static void resolveNum2(int num){\n\t\tint i = 2;\n\t\twhile(num>i){\n\t\t\tif(num%i==0){\n\t\t\t\tSystem.out.print(i+\"*\");\n\t\t\t\tnum = num/i;\n\t\t\t}else{\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tSystem.out.print(num+\";\");\n\t}\n```\n\n** 求任意两个正整数的最大公约数和(GCD)和最小公倍数(LCM).辗转相除法的算法为：首先将 m除以 n（m>n）得余数 r，再用余数  r 去除原来的除数，得新的余数，重复此过程直到余数为 0时停止， 此时的除数就是m 和 n的最大公约数。 求 m和 n的最小公倍数: m和 n的积除以(m和 n 的最大公约数)。**\n\n```\npublic static int printGCD(int num1,int num2){\n\t\tif(num1<num2){\n\t\t\tnum1 = num1 + num2;\n\t\t\tnum2 = num1 - num2;\n\t\t\tnum1 = num1 - num2;\n\t\t}\n\t\tint r = num1%num2;\n\t\tif(r!=0){\n\t\t\tnum1 = num2;\n\t\t\tnum2 = r;\n\t\t\tr = num1%num2;\n\t\t}\n\t\treturn num2;\n\t}\n\t\n\tpublic static int printLCM(int num1,int num2){\n\t\tint gcd = printGCD(num1, num2);\n\t\tint lcm = num1*num2/gcd;\n\t\treturn lcm;\n\t}\n```\n\n** 九九乘法表 **\n\n```\npublic static void printZuoXia(){\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printZuoShang(){\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printYouXia(){\n\t\tfor(int i=1;i<=9;i++){\n\t\t\tfor(int k=1;k<=9-i;k++){\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printYouShang(){\n\t\tfor(int i=9;i>=0;i--){\n\t\t\tfor(int k=1;k<=9-i;k++){\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tfor(int j=1;j<=i;j++){\n\t\t\t\tSystem.out.print(j+\"*\"+i+\"=\");\n\t\t\t\tSystem.out.printf(\"%2d\",(j*i));\n\t\t\t\tSystem.out.print(\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n```\n\n** 求1000以内的完全数,若一个自然数，恰好与除去它本身以外的一切因数的和相等，这种数叫做完全数。例如，6=1+2＋3,28=1＋2＋4＋7＋14,496=1+2+4+8＋16+31+62＋124.先计算所选取的整数a(a的取值1~1000)的因数，将各因数累加于m，若m等于a，则可确认a为完全数 **\n\n```\npublic static void main(String[] args) {\n\t\tSystem.out.println(\"1000以内完全数有：\");\n\t\tfor(int i = 1;i<=1000;i++){\n\t\t\tint sum = 0;\n\t\t\tfor(int j=1;j<=i/2;j++){\n\t\t\t\tif(i%j==0){\n\t\t\t\t\tsum+=j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum==i){\n\t\t\t\tSystem.out.println(i);\n\t\t\t}\n\t\t}\n\t}\n```\n\n** 判断101-200之间有多少个素数，并输出所有素数。只能被1和它本身整除的自然数为素数(质数) **\n\n```\npublic static void printPrime() {\n\t\tint count = 0;\n\t\tfor (int i = 101; i <= 200; i++) {\n\t\t\tboolean isPrime = true;\n\t\t\tfor (int j = 2; j < i; j++) {\n\t\t\t\tif (i % j == 0) {\n\t\t\t\t\tisPrime = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isPrime){\n\t\t\t\tcount++;\n\t\t\t\tSystem.out.print(i + \" \");\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(\"总共有\"+count+\"个素数\");\n\t}\n```\n\n","categories":["corejava"]},{"title":"网络编程","url":"/2019/07/22/corejava_net/","content":"\n## 基于TCP的Socket编程步骤：\n+ 套接字socket：代表通信节点\n\t- 实质：一种独立于协议的网络编程接口。\n\t* 作用：完成两个应用程序之间的数据传输。\n\t+ 类型：流式套接字、数据报套接字、原始套接字。\n1. **服务器程序编写：**\n\t* ①调用ServerSocket(int port)创建一个服务器端套接字，并绑定到指定端口上；\n\t* ②调用accept()，监听连接请求，如果客户端请求连接，则接受连接，返回通信套接字；\n\t* ③调用Socket类的getInputStream和getOutputStream()获取输入流和输出流，开始网络数据的接收和发送；\n\t* ④最后关闭通信套接字。\n2. **客户端程序编写：**\n\t* ①调用Socket()创建一个流套接字，并连接到服务器端； \n\t* ②调用Socket类的getOutputStream()和getInputStream获取输出流和输入流，开始网络数据的发送和接收； \n\t* ③最后关闭通信套接字。\n\n---\n\n**服务端和客户端简单交互**\n\n服务端：\n\n```java\n//基于TCP协议的服务端\npublic class TcpServer {\n\tpublic static void main(String[] args) {\n\t\tServerSocket ss = null;  //声明\n\t\tBufferedReader br = null;\n\t\tPrintWriter pw = null;\n\t\tSocket socket = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建ServerSocket对象\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经在9999端口启动！\");\n\t\t\twhile(true){\n\t\t\t\t//2.监听连接请求，等待客户端请求连接\n\t\t\t\tsocket = ss.accept();  //阻塞作用\n\t\t\t\t//3.基于Socket对象读写数据\n\t\t\t\t//读客户端发来的数据\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t\t//给客户端发出数据\n\t\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\t\tpw.println(new Date().toString());\n\t\t\t\tpw.flush();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\t//关闭资源(先开后关)\n\t\t\ttry {\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(socket!=null)\tsocket.close();\n\t\t\t\tif(ss!=null)\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n```java\n//基于TCP协议的服务器端，使用多线程\npublic class TcpServer2 {\n\tprivate ServerSocket ss;\n\t\n\tpublic TcpServer2() {\n\t\ttry {\n\t\t\tss = new ServerSocket(9999);\n\t\t\tSystem.out.println(\"服务器端已经启动....\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\t//每来一个客户端就启动一个线程来单独处理该客户端和服务端的通信\n\t\t\t\tnew ServerThread(socket).start();\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew TcpServer2();\n\t}\n}\nclass ServerThread extends Thread{\n\tprivate Socket socket;\n\t\n\tpublic ServerThread(Socket socket) {\n\t\tthis.socket = socket;\n\t}\n\t@Override\n\tpublic void run(){\n\t\t//3.基于Socket对象读写数据\n\t\t//读客户端发来的数据\n\t\ttry {\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString msg = br.readLine();   //阻塞作用\n\t\t\tSystem.out.println(\"客户端说:\"+msg);\n\t\t\t//给客户端发出数据\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(new Date().toString());\n\t\t\tpw.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\n//基于TCP的客户端\npublic class TcpClient {\n\tpublic static void main(String[] args) {\n\t\tSocket socket = null;\n\t\tPrintWriter pw = null;\n\t\tBufferedReader br = null;\n\t\t\n\t\ttry {\n\t\t\t//1.创建Socket对象，并绑定IP地址和端口号\n\t\t\tsocket = new Socket(\"127.0.0.1\",9999);\n\t\t\t//2.基于Socket的读写数据\n\t\t\t//客户端给服务端写数据\n\t\t\tpw = new PrintWriter(socket.getOutputStream());\n\t\t\tpw.println(\"请给我你的时间！\");\n\t\t\tpw.flush();\n\t\t\t//接受服务器发来的数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString time = br.readLine();\n\t\t\tSystem.out.println(\"时间为：\"+time);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tif(br!=null)\tbr.close();\n\t\t\t\tif(pw!=null)\tpw.close();\n\t\t\t\tif(socket!=null) \tsocket.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n}\n\n```\n\n---\n\n**聊天室模拟**\n\n服务端：\n\n```java\n//聊天室的服务端\npublic class ChatServer {\n\tprivate ServerSocket ss;\n\tprivate Set<Socket> clients;\n\t\n\tpublic ChatServer(){\n\t\ttry {\n\t\t\tss = new ServerSocket(8888);\n\t\t\tclients = new HashSet<Socket>();\n\t\t\tSystem.out.println(\"聊天室的服务器端已经启动...\");\n\t\t\twhile(true){\n\t\t\t\tSocket socket = ss.accept();\n\t\t\t\tclients.add(socket);\n\t\t\t\t//启动一个线程单独处理该客户端\n\t\t\t\tnew ChatThread(socket,clients).start();\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}finally{\n\t\t\ttry {\n\t\t\t\tss.close();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew ChatServer();\n\t}\n}\n\n//接收客户端的数据并转发给所有的客户端\nclass ChatThread extends Thread{\n\tprivate Socket currentSocket;  //当前客户端\n\tprivate Set<Socket> clients;\n\tpublic ChatThread(Socket currentSocket,Set<Socket> clients) {\n\t\tthis.currentSocket = currentSocket;\n\t\tthis.clients = clients;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\t//读数据\n\t\t\tbr = new BufferedReader(new InputStreamReader(currentSocket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//转发给所有的客户端\n\t\t\t\tfor(Socket client:clients){\n\t\t\t\t\tPrintWriter pw = new PrintWriter(client.getOutputStream());\n\t\t\t\t\tpw.println(str);\n\t\t\t\t\tpw.flush();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class ChatClient extends JFrame {\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate JTextArea sendArea;//要发送信息的内容区域\n\tprivate JTextArea contentArea;//聊天记录的内容区域\n\tprivate Container contentPane;\n\tprivate String name;//当前用户名\n\tprivate Socket socket;\n\t\n\tpublic static void main(String[] args) throws UnknownHostException, IOException {\n\t\tSocket socket = new Socket(\"127.0.0.1\",8888);\n\t\tnew ChatClient(\"张三\",socket).go();\n\t}\n\tpublic ChatClient(String name,Socket socket){\n\t\tthis.name = name;\n\t\tthis.socket = socket;\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tinitGUI();\n\t\t//启动一个子线程，专门接收服务器端传来的数据\n\t\tnew ClientThread(socket,contentArea).start();\n\t}\n\tpublic void initGUI(){\n\t\tthis.setSize(300,400);\n\t\tthis.setTitle(\"我的聊天室\");\n\t\tcontentPane = getContentPane();\n\t\tint x = (int)Toolkit.getDefaultToolkit().getScreenSize().getWidth();\n\t\tint y = (int)Toolkit.getDefaultToolkit().getScreenSize().getHeight();\n\t\tthis.setLocation((x-this.getWidth())/2, (y-this.getHeight())/2);\n\t\tthis.setResizable(false);\n\t\t\n\t\tcontentArea = new JTextArea();\n\t\tcontentArea.setEditable(false);\n\t\tJScrollPane logPanel = new JScrollPane(contentArea,\n\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\tsendArea = new  JTextArea();\n\t\tsendArea.addKeyListener(new KeyAdapter() {\n\t\t\t public void keyPressed(KeyEvent e) {\n\t\t\t\t if(e.getKeyCode()==KeyEvent.VK_ENTER){\n\t\t\t\t\t send();\n\t\t\t\t }\n\t\t\t }\n\t\t});\n\t\tJScrollPane sendPanel = new JScrollPane(sendArea,\n\t\t\t\tJScrollPane.VERTICAL_SCROLLBAR_AS_NEEDED,\n\t\t\t\tJScrollPane.HORIZONTAL_SCROLLBAR_NEVER);\n\t\t//创建一个分割窗口\n\t\tJSplitPane splitPane = new JSplitPane(\n\t\t\t\tJSplitPane.VERTICAL_SPLIT,logPanel,sendPanel);\n\t\tsplitPane.setDividerLocation(250);\n\t\tcontentPane.add(splitPane,BorderLayout.CENTER);\n\t\t\n\t\t//下面的\n\t\tJPanel jp = new JPanel();\n\t\tjp.setLayout(new FlowLayout(FlowLayout.RIGHT));\n\t\tcontentPane.add(jp,BorderLayout.SOUTH);\n\t\t\n\t\tJLabel nameLbl = new JLabel(\"用户名：\"+this.name+\" \");\n\t\tjp.add(nameLbl);\n\t\t\n\t\tJButton resetBtn = new JButton(\"close\");\n\t\tresetBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t});\n\t\tjp.add(resetBtn);\n\t\t\n\t\tJButton sendBtn = new JButton(\"send\");\n\t\tjp.add(sendBtn);\n\t\tsendBtn.addActionListener(new ActionListener(){\n\t\t\tpublic void actionPerformed(ActionEvent e){\n\t\t\t\tsend();\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void go(){\n\t\tthis.setVisible(true);\n\t}\n\tpublic void send (){\n\t\t//获取要发送的信息\n\t\tString msg = sendArea.getText();\n\t\tSimpleDateFormat formater = new SimpleDateFormat(\"HH:mm:ss\");\n\t\tString date = formater.format(new Date());\n\t\tString sendStr = name+\" \"+date+\"说： \"+msg;\n\t\t\n\t\ttry {\n\t\t\tPrintWriter pw = new PrintWriter(socket.getOutputStream());\n\t\t\t//发送数据给服务器\n\t\t\tpw.println(sendStr);\n\t\t\tpw.flush();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t//contentArea.append(sendStr+\"\\n\");\n\t\tsendArea.setText(\"\");\n\t}\n}\n\n//接收服务器端的数据，并显示在界面上\nclass ClientThread extends Thread{\n\tprivate Socket socket;\n\tprivate JTextArea contentArea;\n\t\n\tpublic ClientThread(Socket socket,JTextArea contentArea){\n\t\tthis.socket = socket;\n\t\tthis.contentArea = contentArea;\n\t}\n\t\n\t@Override\n\tpublic void run(){\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tbr = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n\t\t\tString str = null;\n\t\t\twhile((str=br.readLine())!=null){\n\t\t\t\t//显示在界面上\n\t\t\t\tcontentArea.append(str+\"\\n\");\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n\n```\n\n---\n\n## 基于UDP的Socket编程步骤：\n1. **服务器端基于UDP编程：**\n\t- a) 调用DatagramSocket(int port)创建一个数据报套接字，并绑定到指定端口上；\n\t- b) 调用DatagramPacket(byte[] buf, int length)，建立一个字节数组以接收客户端的UDP包 ；\n\t- c) 调用DatagramSocket类的receive()，接收客户端的UDP包并放在上一步创建的数据包中；通过调用DatagramPacket的getData获取数据。\n\t- d) 创建数据包，用来存放发送给客户端响应数据。\n```\n\tint port = dp.getPort();\n\tInetAddress address=dp.getAddress();\n\tString msg=new Date().toString();\n\tbuf=msg.getBytes();\n\tDatagramPacket dp1=new DatagramPacket(buf,buf.length,address,port);\n```\n\t- e) 向客户端发送数据包DatagramSocket.send(DatagramPacket)\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n2. **客户端程序编写：**\n\t- a) 调用DatagramSocket()创建一个数据报套接字。 \n\t- b) 调用DatagramPacket(byte[] buf, int length, InetAddress address, int port)，建立要发送的UDP包；\n\t\t包含发给服务器的数据，服务器地址，服务器的端口。\n\t- c) 调用DatagramSocket类的send(dp)，发送UDP包；\n\t- d) 创建数据包，用来存放服务器端返回响应数据。\n```\n\t\t   DatagramPacket dp1=new DatagramPacket(buf,buf.length);\n```\n\t- e) 接收服务器端响应数据ds.receive(dp1);\n\t- f) 最后关闭数据报套接字。\n\t- 其中第四，五是选择性的。\n\n---\n\n**UDP服务端客户端简单交互**\n\n服务端：\n\n```java\n//基于UDP协议的服务端\npublic class UDPServer {\n\tpublic static void main(String[] args) throws IOException {\n\t\t//1.创建DatagramSocket对象，并绑定端口号\n\t\tDatagramSocket ds = new DatagramSocket(8899);\n\t\tSystem.out.println(\"服务器端已经在8899端口启动......\");\n\t\t//2.接收数据包\n\t\tbyte[] buf = new byte[2048];  //存放数据\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp);//有阻塞功能\n\t\t//3.输出数据包中内容\n\t\tString str = new String(dp.getData());\n\t\tSystem.out.println(\"接收到客户端数据为：\"+str);\n\t\t\n\t\t//4.发送数据包(内容，客户端IP和port\n\t\tString message = new Date().toString();\n\t\tbuf = message.getBytes();  //需要发送的数据\n\t\tint port = dp.getPort();  //获取客户端的端口号\n\t\tInetAddress address = dp.getAddress(); //客户端IP地址\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length, address, port);\n\t\tds.send(dp1);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n客户端：\n\n```java\npublic class UDPClient {\n\tpublic static void main(String[] args) throws Exception{\n\t\t//1.创建DatagramSocket对象，绑定IP地址和端口号\n\t\tDatagramSocket ds = new DatagramSocket();\n\t\t//2.发送数据包\n\t\tbyte[] buf = new byte[2048];\n\t\tbuf = \"give me your time\".getBytes();\n\t\tInetAddress address = InetAddress.getByName(\"127.0.0.1\");  //根据主机名获取InetAddress对象\n\t\tDatagramPacket dp = new DatagramPacket(buf, buf.length,address,8899);\n\t\tds.send(dp);\n\t\t//3.接收数据包\n\t\tDatagramPacket dp1 = new DatagramPacket(buf, buf.length);\n\t\tds.receive(dp1);\n\t\t//输出数据包数据\n\t\tString message = new String(dp1.getData());\n\t\tSystem.out.println(\"接收服务器端数据:\"+message);\n\t\t//关闭资源\n\t\tds.close();\n\t}\n}\n\n```\n\n\n","tags":["java基础"],"categories":["corejava"]},{"title":"IO流","url":"/2019/07/15/io/","content":"# 第七章 IO流\n## 一、流的概念\n+ Java中流是使用统一的方式操作输入和输出的数据。\n+ java.io包它对各种常见的输入流和输出流进行了抽象。\n## 二、流的分类\n1. 流操作的方向（参照物：当前程序）\n   + **输入流**：将数据读取到程序中。\n   + **输出流**：将程序中的数据写出到文件中。\n2. 类操作的最小数据单元\n   + **字节类**：如果数据流中最小的数据单元是字节，那么称这种流为字节流。字节流处理单元为 1 个字节，可以操作字节和字节数组。\n   + **字符类**：如果数据流中最小的数据单元是字符，那么称这种流为字符流。字符流处理的单元为 2 个字节的 Unicode 字符，可以操作字符、字符数组或字符串。Java内用Unicode 编码存储字符,字符流处理类负责将外部的其他编码的字符流和java内Unicode 字符流之间的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。\n3. 流的角色\n   + **字节流**：处理实际数据源，上述四种都是属于字节流。如*FileInputStream*。\n   + **处理流/包装流**:处理包装的流。如*BufferedInputStream*。\n## 三、几种重要的流\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;\n1. 所有字节输入流和字节输出流的父类：\n   + java.io.InputStream\n   + java.io.OutputStream\n2. 文件字节流:\n\tFileInputStream fis = null;\n\tFileOutputStream fos = null;","tags":["java基础"],"categories":["corejava"]},{"title":"Hello World","url":"/2019/06/20/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]